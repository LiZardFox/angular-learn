/**
 Auto-generated by: angular-three-plugin:gltf
 Size: C:\Users\tim.zimmermann\Desktop\learning\angular-learn\public\models\third-person\character.glb [309.75KB] &gt; C:\Users\tim.zimmermann\Desktop\learning\angular-learn\public\models\third-person\character.glb-transformed.glb [237.61KB] (23%)
 */

import type * as THREE from 'three';
import { Group, SkinnedMesh } from 'three';
import {
  extend,
  type NgtThreeElements,
  NgtElementEvents,
  NgtObjectEvents,
  NgtArgs,
} from 'angular-three';
import {
  Component,
  ChangeDetectionStrategy,
  CUSTOM_ELEMENTS_SCHEMA,
  input,
  viewChild,
  ElementRef,
  inject,
  effect,
  model,
} from '@angular/core';
import { gltfResource } from 'angular-three-soba/loaders';
import type { GLTF } from 'three-stdlib';
import {
  animations,
  type NgtsAnimationClips,
  type NgtsAnimationApi,
} from 'angular-three-soba/misc';

// @ts-expect-error - import .glb/.gltf file
import CharacterGLTF from '../../../../../../public/models/third-person/character.glb-transformed.glb' with { loader: 'file' };

gltfResource.preload(CharacterGLTF);

type ActionName =
  | 'dive'
  | 'fall'
  | 'idle'
  | 'jump_air'
  | 'jump_up'
  | 'run'
  | 'walk'
  | 'wave';
type CharacterAnimationClips = NgtsAnimationClips<ActionName>;
export type CharacterAnimationApi = Exclude<
  NgtsAnimationApi<CharacterAnimationClips>,
  { get isReady(): false }
>;

export type CharacterGLTFGLTFResult = GLTF & {
  nodes: {
    leg: THREE.SkinnedMesh;
    body: THREE.SkinnedMesh;
    eye: THREE.SkinnedMesh;
    'hand-': THREE.SkinnedMesh;
    _rootJoint: THREE.Bone;
  };
  materials: {
    Material: THREE.MeshStandardMaterial;
  };
  animations: CharacterAnimationClips[];
};

@Component({
  selector: 'game-character',
  template: `
    @if (gltf.value(); as gltf) {
      @let nodes = gltf.nodes;
      @let materials = gltf.materials;

      <ngt-group #model [parameters]="options()">
        <ngt-group name="fall_guys">
          <ngt-primitive *args="[nodes._rootJoint]" />
        </ngt-group>
        <ngt-skinned-mesh
          name="leg"
          [geometry]="nodes.leg.geometry"
          [material]="materials.Material"
          [skeleton]="nodes.leg.skeleton"
        />
        <ngt-skinned-mesh
          name="body"
          [geometry]="nodes.body.geometry"
          [material]="materials.Material"
          [skeleton]="nodes.body.skeleton"
        />
        <ngt-skinned-mesh
          name="eye"
          [geometry]="nodes.eye.geometry"
          [material]="materials.Material"
          [skeleton]="nodes.eye.skeleton"
        />
        <ngt-skinned-mesh
          name="hand-"
          [geometry]="nodes['hand-'].geometry"
          [material]="materials.Material"
          [skeleton]="nodes['hand-'].skeleton"
        />

        <ng-content />
      </ngt-group>
    }
  `,
  schemas: [CUSTOM_ELEMENTS_SCHEMA],
  changeDetection: ChangeDetectionStrategy.OnPush,
  hostDirectives: [
    {
      directive: NgtObjectEvents,
      outputs: [
        'click',
        'dblclick',
        'contextmenu',
        'pointerup',
        'pointerdown',
        'pointerover',
        'pointerout',
        'pointerenter',
        'pointerleave',
        'pointermove',
        'pointermissed',
        'pointercancel',
        'wheel',
      ],
    },
    {
      directive: NgtElementEvents,
      outputs: ['attached', 'updated', 'created', 'disposed'],
    },
  ],
  imports: [NgtArgs],
})
export class Character {
  protected readonly Math = Math;
  animation = input<ActionName>('idle');
  options = input({} as Partial<NgtThreeElements['ngt-group']>);
  animations = model<CharacterAnimationApi>();

  modelRef = viewChild<ElementRef<Group>>('model');

  protected gltf = gltfResource<CharacterGLTFGLTFResult>(() => CharacterGLTF, {
    useDraco: true,
  });

  constructor() {
    extend({ Group, SkinnedMesh });

    const _animations = animations(this.gltf.value, this.modelRef);
    effect(() => {
      if (!_animations.isReady) return;
      this.animations.set(_animations);
    });

    effect((onCleanup) => {
      const [actionName, animations] = [this.animation(), this.animations()];
      if (!animations || !actionName) return;
      animations.actions[actionName]?.reset().fadeIn(0.24).play();
      onCleanup(() => animations.actions?.[actionName]?.fadeOut(0.24));
    });

    const objectEvents = inject(NgtObjectEvents, { host: true });
    const elementEvents = inject(NgtElementEvents, { host: true });

    objectEvents.ngtObjectEvents.set(this.modelRef);
    elementEvents.ngtElementEvents.set(this.modelRef);
  }
}
